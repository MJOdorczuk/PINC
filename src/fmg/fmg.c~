/* Based on Numerical Recipes in C. */
/* To solve eliptic PDE on 2D grid with the Full Multi Grid method*/
/* If not possible to use fmm, then use Gauss-Seidel method*/


#define NRANSI
#include "nrutil.h"
#include "../const.h"
#include "../funct.h"
//defined in "../const.h"
//#define NPRE 2
//#define NPOST 100
//#define NGMAX 15


// we have external
//int fmg_ng, fmg_nnx, fmg_nny, fmg_mingridx, fmg_mingridy; 
//double **ires[NGMAX+1],**irho[NGMAX+1],**irhs[NGMAX+1],**iu[NGMAX+1];


void mglin_init(int nx, int ny){

void zero(double **u,int x, int y);

int nn,ng,ng1,nn1,nnx,nny,ngrid,nn1x,nn1y,k,j;

ng=0;
fmg_nnx=nx;
fmg_nny=ny;


if(nx==ny)
  {
	nn=nx;
	fmg_mingridx=fmg_mingridy=3;
	while (nn >>= 1) ng++;
	fmg_ng=ng;
	printf("start ng %d nn %d comp %d\n", ng,nn, 1+(1L<<ng)); //getchar();
	if (nx != 1+(1L << ng)) 
	{
      printf("WARNING: cells number is not a power of 2 in mglin. Will use a non-optimal field solver!\n");
	 //find minimal grid
     nn1=nx;
	 ng1=1;
     while((nn1 % 2) == 1)
    	{
          ng1++; nn1=1+(nn1-1)/2;
	    }
	 fmg_mingridx=fmg_mingridy=nn1;
	 fmg_ng=ng1;
      }
	}
else{
   printf("WARNING: cells number is not a power of 2 in mglin. Will use a non-optimal field solver!\n");
	
    nn1=nx;
	ng1=1;
    while((nn1 % 2) == 1)
	{
      ng1++; nn1=1+(nn1-1)/2;
	}
	ng=ng1;
	nn1=ny;
	ng1=1;
    while((nn1 % 2) == 1)
	{
      ng1++; nn1=1+(nn1-1)/2;
	}
	if(ng1 < ng)
       ng=ng1;  
 
	nn1x=nx;
	nn1y=ny;	
	for(k=0; k<ng-1; k++)		
      {
	 	nn1x=1+(nn1x-1)/2;
	 	nn1y=1+(nn1y-1)/2;
	  }
	  
  fmg_mingridx=nn1x;
  fmg_mingridy=nn1y;
  fmg_nnx=nx;
  fmg_nny=ny;
  nnx=nx;
  nny=ny;
  fmg_ng=ng;
}
printf("mglin init: ng %d mingrid %d and %d nnx %d %d\n", fmg_ng, fmg_mingridx, fmg_mingridy, fmg_nnx, fmg_nny);  
if (fmg_ng > NGMAX) nrerror("increase NGMAX in mglin.");
 
// allocate memory for grid arrays
if(fmg_ng>1)
    {
	nnx=fmg_nnx/2+1;
	nny=fmg_nny/2+1;
	ngrid=fmg_ng-1;			
	irho[ngrid]=dmatrix(0,nnx-1,0,nny-1);
	//zero(irho[ngrid],nnx,nny);


while (nnx > fmg_mingridx) {
	nnx=nnx/2+1;
	nny=nny/2+1;
	irho[--ngrid]=dmatrix(0,nnx-1,0,nny-1);
	//	zero(irho[ngrid],nnx,nny);
	}

	nnx=fmg_mingridx;
    nny=fmg_mingridy;
	iu[1]=dmatrix(0,nnx-1,0,nny-1);
	irhs[1]=dmatrix(0,nnx-1,0,nny-1);
	//	zero(iu[1],nnx,nny);
	//		zero(irhs[1],nnx,nny);

	for (j=2;j<=fmg_ng;j++) {
		nnx=2*nnx-1;
		nny=2*nny-1;
		iu[j]=dmatrix(0,nnx-1,0,nny-1);
		irhs[j]=dmatrix(0,nnx-1,0,nny-1);
		ires[j]=dmatrix(0,nnx-1,0,nny-1);	
		//	zero(iu[j],nnx,nny);
		//		zero(irhs[j],nnx,nny);
		//			zero(ires[j],nnx,nny);
    	}	
  }
    
}
		
void zero(double **u,int x, int y)
{
int i,j;
for(i=0; i<x; i++)
for(j=0; j<y; j++)
u[i][j]=0.0;
}


void mglin_destroy(){

int nnx,nny,j;
if(fmg_ng>1)
{
	for (nnx=fmg_nnx, nnx=fmg_nny,j=fmg_ng;j>=2;j--,nnx=nnx/2+1,nny=nny/2+1) {
		free_dmatrix(ires[j],0,nnx-1,0,nny-1);
		free_dmatrix(irhs[j],0,nnx-1,0,nny-1);
		free_dmatrix(iu[j],0,nnx-1,0,nny-1);
		if (j != fmg_ng) free_dmatrix(irho[j],0,nnx-1,0,nny-1);
	}
	free_dmatrix(irhs[1],0,fmg_mingridx-1,0,fmg_mingridy-1);
	free_dmatrix(iu[1],0,fmg_mingridx-1,0,fmg_mingridy-1);
	free_dmatrix(irho[1],0,fmg_mingridx-1,0,fmg_mingridy-1);
}
}


void mglin(double *u, int ncycle)
{
	void addint(double **uf, double **uc, double **res, int nfx, int nfy);
	void copy(double **aout, double **ain, int nx, int ny);
	void copy0(double **aout, double *ain, int nx, int ny);
	void copyfinal(grid **aout, double **ain, int nx, int ny);
	void fill0(double **u, int nx, int ny);
	void interp(double **uf, double **uc, int nfx, int nfy);
	void relax(double **u, double **rhs, int nx, int ny);
	void resid(double **res, double **u, double **rhs, int nx, int ny);
	void rstrct(double **uc, double **uf, int ncx, int ncy);
	void rstrct0(double **uc, double *uf, int ncx, int ncy);
	void slvsml(double **u, double **rhs);
    void slvsml2(double **u, double **rhs, int nx, int ny);
  	
	unsigned int j,jcycle,jj,jpost,jpre,ng=0,ngrid;
	unsigned int  nnx, nny, nfx,nfy;
	
printf("Solving field equations in mglin\n");
/*initialize fmg*/
ng=fmg_ng;
nnx=fmg_nnx;
nny=fmg_nny;

if(ng>1)
 {
	nnx=nnx/2+1;
	nny=nny/2+1;
	ngrid=ng-1;			

  rstrct0(irho[ngrid],u,nnx,nny);

	while (nnx > fmg_mingridx) {
		nnx=nnx/2+1;
		nny=nny/2+1;
		--ngrid;
		rstrct(irho[ngrid],irho[ngrid+1],nnx,nny);
	}
	nnx=fmg_mingridx;
    nny=fmg_mingridy;
if((fmg_mingridx==3) && (fmg_mingridy==3))
	{slvsml(iu[1],irho[1]);  printf("I am using the full multigrid method\n");}
else
  { slvsml2(iu[1],irho[1],fmg_mingridx,fmg_mingridy); printf("I am using the semi - multigrid method (not the best choice of grid size)\n");}
	ngrid=ng;

	for (j=2;j<=ngrid;j++) {
		nnx=2*nnx-1;
		nny=2*nny-1;
		interp(iu[j],iu[j-1],nnx,nny);
  
     if(j!=ngrid)
		copy(irhs[j], irho[j], nnx,nny);
	else
	    copy0(irhs[j], u, nnx,nny);	

		for (jcycle=1;jcycle<=ncycle;jcycle++) {
			nfx=nnx;
            nfy=nny;
			for (jj=j;jj>=2;jj--) {
			for (jpre=1;jpre<=NPRE;jpre++)
				relax(iu[jj],irhs[jj],nfx,nfy);
 
			resid(ires[jj],iu[jj],irhs[jj],nfx,nfy);
			nfx=nfx/2+1;
	        nfy=nfy/2+1;
			rstrct(irhs[jj-1],ires[jj],nfx,nfy);
			fill0(iu[jj-1],nfx,nfy);			
			}
if((fmg_mingridx==3) && (fmg_mingridy==3))
		slvsml(iu[1],irhs[1]);
else
    	slvsml2(iu[1],irhs[1],fmg_mingridx,fmg_mingridy);
			nfx=fmg_mingridx;
			nfy=fmg_mingridy;
			for (jj=2;jj<=j;jj++) {
			nfx=2*nfx-1;
		    nfy=2*nfy-1;
			addint(iu[jj],iu[jj-1],ires[jj],nfx,nfy);

			for (jpost=1;jpost<=NPOST;jpost++)
				relax(iu[jj],irhs[jj],nfx,nfy);
			}
		}
	}
	copyfinal(gp,iu[ngrid],fmg_nnx,fmg_nny);
}
else
{
 int i,ipass, isw,j,jsw;
  int iter=0;
  double h2,hx,hy,error,errorcheck,toler;  
  jsw=1;
  toler=TOLERANCE;
  printf("Wrong grid size to use the multigrid method\nI am solving the potential with the slow converging Gauss-Seidel method\n");
    
      hx=Lx/(fmg_nnx-1);
	  hy=Ly/(fmg_nny-1);
	  h2=hx*hy;
      do
   	{
	  errorcheck=0.5*toler;
	for (ipass=1;ipass<=2;ipass++,jsw=3-jsw) {
		isw=jsw;
		for (j=1;j<fmg_nny-1;j++,isw=3-isw)
			for (i=isw;i<fmg_nnx-1;i+=2)
				{
				  error=gp[i][j].phi;
				  gp[i][j].phi=0.25*(gp[i+1][j].phi+gp[i-1][j].phi+gp[i][j+1].phi+gp[i][j-1].phi+h2*u[ix(0,i,j)]);
				  error=gp[i][j].phi-error;
					if(error < 0) error*=-1;
						if(errorcheck < error)
                    errorcheck=error;
             }
		  }
	  iter++;
	}
      while(errorcheck>toler);
     
	printf("END %d iterations\n", iter);
}
}
//#undef NPRE
//#undef NPOST
//#undef NGMAX
#undef NRANSI


void rstrct(double **uc, double **uf, int ncx, int ncy)
{
   	int ic,iif,jc,jf,nccx, nccy;
    /*set ncc to be the dimension of the larger grid*/
    nccx = 2*ncx-2; /*previously*/
    nccy = 2*ncy-2; /*previously*/

	for (jf=2,jc=1;jc<ncy-1;jc++,jf+=2) {
		for (iif=2,ic=1;ic<ncx-1;ic++,iif+=2) {
			uc[ic][jc]=0.5*uf[iif][jf]+0.125*(uf[iif+1][jf]+uf[iif-1][jf]+uf[iif][jf+1]+uf[iif][jf-1]);
		}
	}
	for (jc=0,ic=0;ic<ncx;ic++,jc+=2) {
		uc[ic][0]=uf[jc][0];
		uc[ic][ncy-1]=uf[jc][nccy];
	}

	for (jc=0,ic=0;ic<ncy;ic++,jc+=2) {
		uc[0][ic]=uf[0][jc];
		uc[ncx-1][ic]=uf[nccx][jc];
	}

}
/*************************************************/

void rstrct0(double **uc, double *uf, int ncx, int ncy)
{
   	int ic,iif,jc,jf,nccx, nccy;
    /*set ncc to be the dimension of the larger grid*/
    nccx = 2*ncx-2; /*previously*/
    nccy = 2*ncy-2; 
	for (jf=2,jc=1;jc<ncy-1;jc++,jf+=2) {
		for (iif=2,ic=1;ic<ncx-1;ic++,iif+=2) {
			uc[ic][jc]=0.5*uf[ix(0,iif,jf)]+0.125*(uf[ix(0,iif+1,jf)]+uf[ix(0,iif-1,jf)]+uf[ix(0,iif,jf+1)]+uf[ix(0,iif,jf-1)]);
		}
	}
	for (jc=0,ic=0;ic<ncx;ic++,jc+=2) {
		uc[ic][0]=uf[ix(0,jc,0)];
		uc[ic][ncy-1]=uf[ix(0,jc,nccy)];
	}

	for (jc=0,ic=0;ic<ncy;ic++,jc+=2) {
		uc[0][ic]=uf[ix(0,0,jc)];
		uc[ncx-1][ic]=uf[ix(0,nccx,jc)];
	}
}
/*************************************************/

void interp(double **uf, double **uc, int nfx, int nfy)
{
	int ic,iif,jc,jf,ncx, ncy;
	ncx=nfx/2+1;
	ncy=nfy/2+1;

	for (jc=0,jf=0;jc<ncy;jc++,jf+=2)
		for (ic=0;ic<ncx;ic++) uf[2*ic][jf]=uc[ic][jc];
		
	for (jf=0;jf<nfy;jf+=2)
		for (iif=1;iif<nfx-1;iif+=2)
			uf[iif][jf]=0.5*(uf[iif+1][jf]+uf[iif-1][jf]);
	for (jf=1;jf<nfy-1;jf+=2)
		for (iif=0;iif <nfx;iif++)
			uf[iif][jf]=0.5*(uf[iif][jf+1]+uf[iif][jf-1]);
}
/**************************************************/
void addint(double **uf, double **uc, double **res, int nfx, int nfy)
{
	void interp(double **uf, double **uc, int nfx, int nfy);
	int i,j;

	interp(res,uc,nfx,nfy);
	for (i=0;i<nfx;i++)
		for (j=0;j<nfy;j++)
			uf[i][j] += res[i][j];
}
/**************************************************/
void slvsml(double **u, double **rhs)
{	
	void fill0(double **u, int nx, int ny);
	double h=Lx*0.5;
	fill0(u,3,3);
	u[1][1] = h*h*rhs[1][1]/4.0;
}

/**************************************************/
void slvsml2(double **u, double **rhs, int nx, int ny)
{
	int i,ipass,isw,j,jsw=1;
	double hx,hy,h2;
	double toler, error, errorcheck;
	void fill0(double **u, int nx, int ny);
	int iter=0;
    fill0(u,nx,ny);
	hx=Lx/(nx-1);
	hy=Ly/(ny-1);
	h2=hx*hy;
	toler=TOLERANCE;
	do
	{
	iter++;
	errorcheck=0.5*toler;
	for (ipass=1;ipass<=2;ipass++,jsw=3-jsw) {
		isw=jsw;
		for (j=1;j<ny-1;j++,isw=3-isw)
			for (i=isw;i<nx-1;i+=2)
				{
				error=u[i][j];
				u[i][j]=0.25*(u[i+1][j]+u[i-1][j]+u[i][j+1]+u[i][j-1]+h2*rhs[i][j]);
                error=u[i][j]-error;
                if(errorcheck < fabs(error))
                errorcheck=fabs(error);				
	            }
	}
	}
	while(errorcheck>toler);
}

/**************************************************/
void relax(double **u, double **rhs, int nx, int ny)
{
	int i,ipass,isw,j,jsw=1;
	double hx,hy,h2;
	hx=Lx/(nx-1);
	hy=Ly/(ny-1);
	h2=hx*hy;
	for (ipass=1;ipass<=2;ipass++,jsw=3-jsw) {
		isw=jsw;
		for (j=1;j<ny-1;j++,isw=3-isw)
			for (i=isw;i<nx-1;i+=2)
				u[i][j]=0.25*(u[i+1][j]+u[i-1][j]+u[i][j+1]+u[i][j-1]+h2*rhs[i][j]);
	}
}
/**************************************************/
void resid(double **res, double **u, double **rhs, int nx, int ny)
{
	int i,j;
	double hx,hy,h2i;
	
	hx=Lx/(nx-1);
	hy=Ly/(ny-1);	
	h2i=1.0/(hx*hy);
	
	for (i=1;i<nx-1;i++)
		for (j=1;j<ny-1;j++)
			res[i][j] = h2i*(u[i+1][j]+u[i-1][j]+u[i][j+1]+u[i][j-1]-4.0*u[i][j])+rhs[i][j];
	for (i=0;i<nx;i++)
		res[i][0]=res[i][ny-1]=0.0;
	for (i=0;i<ny;i++)
		res[0][i]=res[nx-1][i]=0.0;
}
/***************************************************/
void copy(double **aout, double **ain, int nx, int ny)
{
	int i,j;
	for (i=0;i<nx;i++)
		for (j=0;j<ny;j++)
			aout[i][j]=ain[i][j];
}
/***************************************************/
void copy0(double **aout, double *ain, int nx, int ny)
{
	int i,j;
	for (i=0;i<nx;i++)
		for (j=0;j<ny;j++)
			aout[i][j]=ain[ix(0,i,j)];
}
/***************************************************/
void copyfinal(grid **aout, double **ain, int nx, int ny)
{
	int i,j;                    
	for (i=0;i<nx;i++)
		for (j=0;j<ny;j++)
			aout[i][j].phi=ain[i][j];
}
/***************************************************/
void fill0(double **u, int nx, int ny)
{
	int i,j;
	for (i=0;i<nx;i++)
		for (j=0;j<nx;j++)
			u[i][j]=0.0;
}
/***************************************************/


