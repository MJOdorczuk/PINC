#define _XOPEN_SOURCE 700

#include "stool.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define GETLINESBUFFER 4096		// fgetlines() gets faster for larger buffers
#define GPSCRIPT "gplot.gp"		// Filename for gnuplot-script generated by gplot
#define GPDATA "gplot.data"		// Filename for data generated by gplot

/*
 * VECTOR FUNCTIONS (v-functions)
 *
 * Intended to ease operations on vectors.
 * Follows the following standard syntax:
 *
 * vfunction(double *v, int N)
 * vfunction(double *v, int N, double value)
 *
 * where v points to the vector of length N.
 *
 * Example of use:
 *
 * 		Let energy be computed each time step and stored in vector E.
 * 		Initial energy is then E[0] and energy should be conserved.
 * 		Then, the maximum percentage-wise error is found as:
 *
 * 			error = 100*vdev(E,N,E[0])/E[0];
 *
 */

// Set all elements to value
void vsetall(double *v, int N, double value){

	for(int i=0;i<N;i++) v[i]=value;

}

// Find max value in a vector
double vmax(double *v, int N){

	double max = v[0];
	for(int i=1;i<N;i++){
		if(v[i]>max) max=v[i];
	}
	return max;

}

// Find min value in a vector
double vmin(double *v, int N){

	double min = v[0];
	for(int i=1;i<N;i++){
		if(v[i]<min) min=v[i];
	}
	return min;

}

// Find the value whose absolute value is the largest
double vext(double *v, int N){

	double max = vmax(v,N);
	double min = vmin(v,N);

	if(max>-min) return max;
	else return min;

}

// Find average
double vavg(double *v, int N){

	double avg=0;

	for(int i=0;i<N;i++){
		avg += v[i];
	}

	avg /= N;
	return avg;

}

// Add scalar to vector
void vadd(double *v, int N, double value){

	for(int i=0;i<N;i++){
		v[i] += value;
	}

}

// Multiply vector by scalar
void vmul(double *v, int N, double value){

	for(int i=0;i<N;i++){
		v[i] *= value;
	}

}

// Print vector
void vprint(double *v, int N){

	printf("[%f",v[0]);
	for(int i=1;i<N;i++){
		printf("\t%f",v[i]);
	}
	printf("]\n");

}


// Find the largest (absolute) deviation from value.
// Divide output by "value" to get relative deviation.
double vdev(double *v, int N, double value){

	double maxdev = 0;

	for(int i=0;i<N;i++){
		double dev = v[i]-value;
		if(dev>maxdev) maxdev=dev;
		if(-dev>maxdev) maxdev=-dev;
	}

	return maxdev;

}

/*
 * TIMING FUNCTIONS (t-functions)
 *
 * Intended as simple profiling tool, e.g. to keep track of execution time
 * of various parts and enable comparison of various implementations with
 * respect to execution time.
 *
 * Every time the time probe (T-probe) is called it will report in the console
 * what the total run time of the program is so far, and how long it has been
 * since the last call of the T-probe. This difference can be used to probe
 * the execution time of different parts of the code, almost like a multilap
 * stop watch. Each call is labeled by a string for the users convenience
 * (i.e. to recognize what took what time).
 *
 * Example of use:
 *
 * 		tprobe("Start");	// Program spends a few ms on starting
 *
 * 		// INITIALIZE DATA
 *
 * 		tprobe("Initializing data");	// Outputs the time spent on initializing
 *
 * 		// SOLVE EQUATIONS
 *
 * 		tprobe("Solver");	// Outputs the time spent solving equations
 *
 */

// Formats and prints the time variable "time".
// Mainly for use in tprobe()
void tprint(struct timespec *time){

	long int sec = time->tv_sec;
	long int nsec = time->tv_nsec;

	if(sec>=1){
		printf("%.2fs",(double)sec+(double)nsec/1000000000);
	} else if(nsec>1000000) {
		printf("%.1fms",(double)nsec/1000000);
	} else if(nsec>1000) {
		printf("%.1fus",(double)nsec/1000);
	} else {
		printf("%ldns",nsec);
	}

}

// Time probe. See example above.
void tprobe(const char * label){

	static struct timespec previous;	// time of previous tprobe call

	struct timespec now, diff;
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &now);

	// Take difference
	diff.tv_sec = now.tv_sec-previous.tv_sec;
	diff.tv_nsec = now.tv_nsec-previous.tv_nsec;

	// Borrow from tv_sec if necessary
	if(diff.tv_nsec<0){
		diff.tv_sec-=1;
		diff.tv_nsec+=1e9;
	}

	// Print
	printf("T-probe: total=");
	tprint(&now);
	printf(", diff=");
	tprint(&diff);
	printf(" (%s)\n",label);

	// Store current time till next execution
	previous = now;


}

/*
 * FILE HANDLING FUNCTIONS (f-functions)
 *
 * Complements standard C file handling functsions such as fopen,
 * fgets, fclose and so on.
 *
 */

/* DEPRECATED

// Basic function to get number of lines of text file
unsigned long fgetlinesb(char *fname) {
    FILE *fp = fopen(fname, "r");
    unsigned long lines = 0;

    if(fp==NULL) return 0;	// Can't read file (doesn't exist or permission problem)

    int c;
    while((c=fgetc(fp))!=EOF){	// Read new character until End-of-File
    	if(c=='\n') lines++;
    }

    fclose(fp);
    return lines;
}

*/
/*
// Function to get number of lines from text file
// Same as fgetlinesb() but faster since it reads chunks of data into a buffer
// thereby reducing the number of file read operations
unsigned long fgetlines(const char *fname) {
    FILE *fp = fopen(fname, "r");
    unsigned long lines = 0;

    if(fp==NULL) return 0;	// Can't read file (doesn't exist or permission problem)

    char buffer[GETLINESBUFFER];
    unsigned long chars;

    while((chars=fread(buffer,sizeof(char),GETLINESBUFFER,fp))!=NULL){	// Reads chunks of data until end-of-file
    	for(int i=0;i<chars;i++){										// Scans through characters in each chunk
    		if(buffer[i]=='\n') lines++;
    	}
    }

    fclose(fp);
    return lines;
}

/*
 * GRAPHICS FUNCTIONS (g-functions)
 *
 * Intended to ease visualization of vector data, built around GNUplot,
 * but inspired from the plotting functions in MATLAB.
 *
 * Example of use:
 *
 * 		A minimum example of plotting an array y with gplot() is:
 *
 * 			gplot(NULL,y,N,NULL);
 * 			gdraw();
 *
 * 		where N is the length of y. Since no x-values are provided the
 * 		indices of y will be used on the x-axis. Note that the plot is not
 * 		drawn until gdraw() is called.
 *
 * Example of use:
 *
 * 		Let the arrays f and g represent functions of x to be plotted
 * 		in the same window. All arrays have length N.
 *
 *			gtitle("My Functions");
 *			gxlabel("x");
 *			gylabel("y");
 *			gxrange(0.0,2.5);
 *			gyrange(-1.2,1.2);
 *			ggrid();
 *
 *			gplot(x,f,N,"f(x)");
 *			gplot(x,g,N,"g(x)");
 *			gdraw();
 *
 *		Since two gplot-calls happens before gdraw() the two plots will
 *		occur in the same coordinates. Note the order of the function calls.
 *		No g-functions can occur between gplot() and gdraw().
 *
 *	Example of use:
 *
 *		The fastest way to plot a variable, for instance the energy stored in
 *		the array E, is to use the quick-plot function gqplot():
 *
 *			gqplot(x,E,N,'Energy');
 *
 *		This does not, however, allow much flexibility.
 */
/*
// Make plot of y(x). Set x==NULL to use indices as x-axis.
// gdraw() must be called afterwards to execute plotting.
// gplot() can be called multiple times to make several plots in same window.
void gplot(const double *x, const double *y, int N, const char *legend){

	double *xaxis;

	if(x==NULL){	// Use indices as default x-axis
		xaxis = (double *)malloc(N*sizeof(double));
		for(int i=0;i<N;i++){
			xaxis[i]=i;
		}
	} else {
		xaxis = x;
	}

	// Which lines the data for this plot will start and stop at
	int start = (int)fgetlines(GPDATA);
	int stop = start+N-1;

	// Append data to data file
	FILE *data = fopen(GPDATA,"a");
	for(int i=0;i<N;i++){
		fprintf(data, "%e %e\n", xaxis[i], y[i]);
	}
	fclose(data);

	// Append command parameters for gdraw to execute
	FILE *cmd = fopen(GPSCRIPT,"a");
	if(start==0){	// This is the first curve
		fprintf(data, "plot ");
	} else {		// This is Nth curve and thereby only adds to the gnuplot command
		fprintf(data, ", ");
	}
	if(legend==NULL){
		fprintf(data, "'%s' every ::%u::%u notitle w l",GPDATA,start,stop);
	} else {
		fprintf(data, "'%s' every ::%u::%u title '%s' w l",GPDATA,start,stop,legend);
	}
	fclose(cmd);

	if(x==NULL) free(xaxis);
}

// Call this function to execute plots
void gdraw(){

	FILE *gnuplot = popen("gnuplot -persistent", "w");
	fprintf(gnuplot, "load '%s'\n", GPSCRIPT);
	pclose(gnuplot);

	remove(GPSCRIPT);
	remove(GPDATA);

}

// Quick-plot
void gqplot(const double *x, const double *y, int N, const char *title){

	gtitle(title);
	ggrid();
	gplot(x,y,N,NULL);
	gdraw();

}

// Get file-pointer to gnuplot-script.
FILE* gget(){
	return fopen(GPSCRIPT,"a");
}

// Call this function to run gnuplot commands directly
void gcmd(const char* str){
	FILE *cmd = fopen(GPSCRIPT,"a");
	fprintf(cmd,"%s\n",str);
	fclose(GPSCRIPT);
}

// Set title for plot (run before gplot())
void gtitle(const char *str){

//	fprintf(gnupipe, "set title \"%s\"\n",str);
	FILE *cmd = fopen(GPSCRIPT,"a");
	fprintf(cmd,"set title '%s'\n",str);
	fclose(cmd);

}

// Set label on x-axis (run before gplot())
void gxlabel(const char *str){

//	fprintf(gnupipe, "set xlabel \"%s\"\n",str);
	FILE *cmd = fopen(GPSCRIPT,"a");
	fprintf(cmd,"set xlabel '%s'\n",str);
	fclose(cmd);

}

// Set label on y-axis (run before gplot())
void gylabel(const char *str){

//	fprintf(gnupipe, "set ylabel \"%s\"\n",str);
	FILE *cmd = fopen(GPSCRIPT,"a");
	fprintf(cmd,"set ylabel '%s'\n",str);
	fclose(cmd);

}

// Set x-axis range (run before gplot())
void gxrange(double from, double to){

//	fprintf(gnupipe, "set xrange [%f,%f]\n",from,to);
	FILE *cmd = fopen(GPSCRIPT,"a");
	fprintf(cmd,"set xrange [%f:%f]\n",from,to);
	fclose(cmd);

}

// Set y-axis range (run before gplot())
void gyrange(double from, double to){

//	fprintf(gnupipe, "set xrange [%f,%f]\n",from,to);
	FILE *cmd = fopen(GPSCRIPT,"a");
	fprintf(cmd,"set yrange [%f:%f]\n",from,to);
	fclose(cmd);

}


// Turn on grid lines (run before gplot())
void ggrid(){

	FILE *cmd = fopen(GPSCRIPT,"a");
	fprintf(cmd,"set grid\n");
	fclose(cmd);

}

void gclose(){

	FILE * bash = popen("bash","w");
	fprintf(bash, "killall -q gnuplot_x11\n");
	fprintf(bash, "killall -q gnuplot\n");
	pclose(bash);

}

void storecsv(char *fname, double *x, double *y, int length, char *param){

	double *xaxis;

	if(x==NULL){	// Use indices as default x-axis
		xaxis = (double *)malloc(length*sizeof(double *));
		for(int i=0;i<length;i++){
			xaxis[i]=i;
		}
	} else {
		xaxis = x;
	}

	FILE * data = fopen(fname,"w");
	for(int i=0;i<length;i++){
//		if(param=="abs")
//			fprintf(data, "%e %e \n", xaxis[i], cabs(y[i]));
//		else
			fprintf(data, "%e %e\n", xaxis[i], (y[i]));
	}
	fprintf(data,"\n");
	fclose(data);

	if(x==NULL) free(xaxis);

}

/*
 * Plots a simple plot of all points (x,y) with lines in between.
 * "lenght" specifies the length of x and y, and the plot will be
 * labelled by "title". If x==NULL the indices of y will be used
 * as x-axis.
 */
/*
void gnuplot1d(char *title, double *x, double *y, int length){

	storecsv("data.temp",x,y,length,NULL);

	// Opening gnuplot console and plotting

	FILE * gnuplot = popen("gnuplot -persistent", "w");
	fprintf(gnuplot, "set title \"%s\"\n",title);
	fprintf(gnuplot, "plot 'data.temp' w lp\n");
	pclose(gnuplot);


}
*/
